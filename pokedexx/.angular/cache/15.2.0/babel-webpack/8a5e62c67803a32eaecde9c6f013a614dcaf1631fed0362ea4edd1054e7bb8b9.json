{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar memoize = require(\"lodash/memoize\");\nvar factory_1 = require(\"./factory\");\nvar applicators_1 = require(\"./applicators\");\n/**\n * Creates a function that memoizes the result of func. If resolver is provided,\n * it determines the cache key for storing the result based on the arguments provided to the memoized function.\n * By default, the first argument provided to the memoized function is used as the map cache key.\n * The func is invoked with the this binding of the memoized function.\n *\n * You can use a Function or a string that references a method on the class as the resolver.\n * You can also use a configuration object that lets provide a prexisting cache or specify\n * the map type to use.\n *\n * @example\n *\n * class MyClass {\n *   @Memoize({ type: WeakMap })\n *   getName(item) {\n *     return item.name;\n *   }\n *\n *   @Memoize('getName')\n *   getLastName(item) {\n *     return item.lastName;\n *   }\n * }\n */\nexports.Memoize = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(memoize, new applicators_1.MemoizeApplicator(), {\n  optionalParams: true\n}));\nexports.memoize = exports.Memoize;\nexports.default = exports.Memoize;","map":{"version":3,"names":["Object","defineProperty","exports","value","memoize","require","factory_1","applicators_1","Memoize","DecoratorFactory","createInstanceDecorator","DecoratorConfig","MemoizeApplicator","optionalParams","default"],"sources":["/home/kalidevi/Documents/GitHub/AngularPractice/pokedexx/node_modules/lodash-decorators/memoize.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar memoize = require(\"lodash/memoize\");\nvar factory_1 = require(\"./factory\");\nvar applicators_1 = require(\"./applicators\");\n/**\n * Creates a function that memoizes the result of func. If resolver is provided,\n * it determines the cache key for storing the result based on the arguments provided to the memoized function.\n * By default, the first argument provided to the memoized function is used as the map cache key.\n * The func is invoked with the this binding of the memoized function.\n *\n * You can use a Function or a string that references a method on the class as the resolver.\n * You can also use a configuration object that lets provide a prexisting cache or specify\n * the map type to use.\n *\n * @example\n *\n * class MyClass {\n *   @Memoize({ type: WeakMap })\n *   getName(item) {\n *     return item.name;\n *   }\n *\n *   @Memoize('getName')\n *   getLastName(item) {\n *     return item.lastName;\n *   }\n * }\n */\nexports.Memoize = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(memoize, new applicators_1.MemoizeApplicator(), { optionalParams: true }));\nexports.memoize = exports.Memoize;\nexports.default = exports.Memoize;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,IAAIC,OAAO,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACvC,IAAIC,SAAS,GAAGD,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIE,aAAa,GAAGF,OAAO,CAAC,eAAe,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,OAAO,CAACM,OAAO,GAAGF,SAAS,CAACG,gBAAgB,CAACC,uBAAuB,CAAC,IAAIJ,SAAS,CAACK,eAAe,CAACP,OAAO,EAAE,IAAIG,aAAa,CAACK,iBAAiB,EAAE,EAAE;EAAEC,cAAc,EAAE;AAAK,CAAC,CAAC,CAAC;AAC7KX,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACM,OAAO;AACjCN,OAAO,CAACY,OAAO,GAAGZ,OAAO,CAACM,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}